{"data":{"mdx":{"id":"eb5c18e5-3b3e-5724-b55a-a3c1a6cfd2b6","code":{"body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nreturn class MDXContent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.layout = null;\n  }\n\n  render() {\n    const _this$props = this.props,\n          {\n      components\n    } = _this$props,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n    return React.createElement(MDXTag, {\n      name: \"wrapper\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `These notes are provisional, as the protocol between front-end and\nback-end (aka \"core\") is expected to evolve. Even so, it might be\ninteresting to experiment with new front-ends other than the official\nCocoa one. This document captures the protocol as it exists (and\nshould be updated as it changes).`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The front-end starts the core process and communicates to it through\nstdin and stdout. The outer layer is based heavily on `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"http://www.jsonrpc.org/specification\"\n      }\n    }, `JSON-RPC\n2`), `, communicating over stdin and\nstdout, with messages encoded in UTF-8 and terminated in newlines.\nHowever, there are two differences. Most importantly, the protocol is\npeer-to-peer rather than defining strict server and client roles; both\npeers can send RPC's to the other. To reflect that it is not exactly\nJSON-RPC 2, the \"jsonrpc\" parameter is missing.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `A mixture of synchronous and asynchronous RPC's is used. Most editing\ncommands are sent as asynchronous RPC's, with the expectation that\nthe core will send an (also asynchronous) `, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"p\"\n    }, `update`), ` RPC with the\nupdated state.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When the front-end quits, it closes the stdin pipe, and the core\nis expected to quit silently.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `The protocol is currently not versioned, as there is only one\nofficial front-end, and it is distributed along with the back-end;\nboth should change in lock step. That may well change if and when\nthere are other front-ends developed independently, in which case a\nsimple version negotiation at startup will support a small window of\nversions.`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `First steps`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `When a frontend is initialized, the first thing it does is launch and connect to\nthe core. Currently, the core is always run as a process, although we expect at\nsome point it could be run in the client process as a library.`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `After establishing a connection with the core, the client sends the\n`, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"#client_started\"\n      }\n    }, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"a\"\n    }, `client_started`)), ` RPC. Core will respond by notifying the\nclient of some initial state, such as a list of available themes. The client\nthen normally sends a `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"#new_view\"\n      }\n    }, React.createElement(MDXTag, {\n      name: \"inlineCode\",\n      components: components,\n      parentName: \"a\"\n    }, `new_view`)), ` request; when it receives\na response it can begin sending editing operations against that view.`), React.createElement(MDXTag, {\n      name: \"h3\",\n      components: components\n    }, `Additional Resources`), React.createElement(MDXTag, {\n      name: \"p\",\n      components: components\n    }, `This document is not always perfectly up to date. For a comprehensive list of\nsupported commands, the canonical resource is the source, specifically `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"p\",\n      props: {\n        \"href\": \"https://github.com/xi-editor/xi-editor/blob/master/rust/core-lib/src/rpc.rs\"\n      }\n    }, `rust/core-lib/src/rpc.rs`), `.`), React.createElement(MDXTag, {\n      name: \"ul\",\n      components: components\n    }, React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `The protocol is described in\n`, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"li\",\n      props: {\n        \"href\": \"frontend-protocol.md\"\n      }\n    }, `docs/frontend-protocol.md`), `.`), React.createElement(MDXTag, {\n      name: \"li\",\n      components: components,\n      parentName: \"ul\"\n    }, `The config system is explained in more detail in `, React.createElement(MDXTag, {\n      name: \"a\",\n      components: components,\n      parentName: \"li\",\n      props: {\n        \"href\": \"config.md\"\n      }\n    }, `docs/config.md`), `.`)));\n  }\n\n}"},"excerpt":"These notes are provisional, as the protocol between front-end and\nback-end (aka \"core\") is expected to evolve. Even so, it might be\ninteresting to experiment with new front-ends other than the official\nCocoa one. This document captures the protocol as it exists (and\nshould be updated as it changesâ€¦","frontmatter":{"title":"Notes on writing front-ends"}},"allMdx":{"edges":[{"node":{"id":"377559fd-4d6d-5280-9b60-dc6b46ea14b9","fields":{"slug":"/frontend-protocol.1/"},"frontmatter":{"title":"The Frontend Protocol"}}},{"node":{"id":"eb5c18e5-3b3e-5724-b55a-a3c1a6cfd2b6","fields":{"slug":"/frontend-notes/"},"frontmatter":{"title":"Notes on writing front-ends"}}},{"node":{"id":"bcf93b0a-ce67-5b53-9d9c-cb8cecedda7c","fields":{"slug":"/frontend-protocol/"},"frontmatter":{"title":"The Frontend Protocol"}}},{"node":{"id":"586f0992-4df6-5aff-ab4d-4d001717fdb7","fields":{"slug":"/plugin/"},"frontmatter":{"title":"Plugin architecture"}}},{"node":{"id":"c52e11a1-2ec8-5aed-ae24-c348d815e5ad","fields":{"slug":"/config/"},"frontmatter":{"title":"Working with the config system"}}},{"node":{"id":"8d6ee533-793b-53cc-87a1-2f1c34e2c2f2","fields":{"slug":"/crdt/"},"frontmatter":{"title":"CRDT - An approach to async plugins and undo"}}},{"node":{"id":"f0e30ba2-3b2d-549c-9b6a-735be81510c2","fields":{"slug":"/crdt-details/"},"frontmatter":{"title":"CRDT - The Xi Text Engine"}}},{"node":{"id":"5bbb9cf5-ff60-52f8-a003-e3882a1b7309","fields":{"slug":"/fuchsia-ledger-crdts/"},"frontmatter":{"title":"CRDT - Using the Ledger for CRDTs"}}},{"node":{"id":"375a35e7-76a5-5da9-bc31-5a3938b28218","fields":{"slug":"/rope-science-00/"},"frontmatter":{"title":"Rope science - Introduction"}}},{"node":{"id":"b28f280e-b2e5-5eee-9d5e-f605fbcdd251","fields":{"slug":"/rope-science-01/"},"frontmatter":{"title":"Rope science, part 1 - MapReduce for text"}}},{"node":{"id":"2c0fcbef-2a60-531f-a7e2-b1d13b72d4d9","fields":{"slug":"/rope-science-02/"},"frontmatter":{"title":"Rope science, part 2 - metrics"}}},{"node":{"id":"bfa895b4-5b90-5766-87d3-73300d6c75e6","fields":{"slug":"/rope-science-03/"},"frontmatter":{"title":"Rope science, part 3 - Grapheme cluster boundaries"}}},{"node":{"id":"177edfe8-21d9-539d-9bb8-467da07dfae9","fields":{"slug":"/rope-science-04/"},"frontmatter":{"title":"Rope science, part 4 - parenthesis matching"}}},{"node":{"id":"a4c8952a-ee4f-5ff0-bd25-caa35f52e05a","fields":{"slug":"/rope-science-05/"},"frontmatter":{"title":"Rope science, part 5 - incremental word wrapping"}}},{"node":{"id":"e39af624-e9c6-5ea2-b6fc-2ed34020ec09","fields":{"slug":"/rope-science-06/"},"frontmatter":{"title":"Rope science, part 6 - parallel and asynchronous word wrapping"}}},{"node":{"id":"d5d0c9f5-2466-5157-b327-4c09985966c6","fields":{"slug":"/rope-science-08/"},"frontmatter":{"title":"Rope science, part 8 - CRDTs for concurrent editing"}}},{"node":{"id":"c0341fdb-b2d4-5957-94f7-b7281de4c70e","fields":{"slug":"/rope-science-09/"},"frontmatter":{"title":"Rope science, part 9 - CRDT Approach to Async Plugins and Undo"}}},{"node":{"id":"04583f02-ba9e-507e-95a0-a481d948f8a5","fields":{"slug":"/rope-science-10/"},"frontmatter":{"title":"Rope science, part 10 - designing for a conflict-free world"}}},{"node":{"id":"996c58eb-59ad-5e1e-841e-382fc08d23bb","fields":{"slug":"/rope-science-11/"},"frontmatter":{"title":"Rope science, part 11 - practical syntax highlighting"}}},{"node":{"id":"e118ecf7-5013-50ec-90b2-1f56d7bb1bac","fields":{"slug":"/rope-science-12/"},"frontmatter":{"title":"Rope science, part 12 - minimal invalidation"}}}]}},"pageContext":{"id":"eb5c18e5-3b3e-5724-b55a-a3c1a6cfd2b6"}}