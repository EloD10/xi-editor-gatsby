{"data":{"markdownRemark":{"id":"c8b885e6-57e4-5e66-9651-7b47f528793d","html":"<p><em>24 Nov 2017</em></p>\n<p>This post describes some of the motivations, theory, and implementation behind\n\"minimal invalidation\" (also tracked in issue #317).</p>\n<p>A major part of the philosophy of performance in xi is that as much of the processing\nas possible is <em>incremental.</em> Basically, this means that a change to the document\nis represented as an explicit <em>delta,</em> then this delta propagates through the\nrendering pipeline. Ideally, the code touches only a tiny part of the document.</p>\n<p>Here we will talk mostly about the implementation in the core, but getting small\ndeltas to the front-end is also important. In an incremental style the front-end\ncan re-render only what's in the delta, and then ideally use graphics hardware to\nre-composite the document view, resulting in much improved latency and power\nconsumption, among other things.</p>\n<p>Note that an incremental style is not the only way to write a performant editor.\nIf rendering is fast, then it's much simpler to just re-render the entire document\nwindow on every update. That is very much the style of video games, for example,\nwhere they have to re-draw the world on every frame in any case.</p>\n<h2 id=\"the-render-function\"><a href=\"#the-render-function\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The render function</h2>\n<p>Here, we'll consider rendering the document as a purely functional program. The\ncore's responsibility is to produce a sequence of <em>rendered lines,</em> which are\nbasically strings with attributes for syntax highlighting and selection carets.\nObviously, further stages in the pipeline (all in the front-end) convert this\nrepresentation into pixels displayed on a screen.</p>\n<p>The input to the render function consists of the text (conceptually just a string),\nstyle spans, the selection, and the line breaks (when word wrapping is in effect).\nThere's also some other stuff, like the results of a \"find\" command, but let's keep\nit simple for now. In fact, to keep things really simple, let's just focus on the\ntext, as the concepts are similar, it's just more merging of more inputs.</p>\n<p>The line breaks structure is conceptually just a sequence of offsets corresponding\nto the end of each line. (See the rope science posts on <a href=\"rope_science_02.md\">Metrics</a>\nand <a href=\"rope_science_06.md\">Word Wrapping</a> for more on how these breaks are determined\nand represented).</p>\n<p>Thus, as an imperative program, the simplified render function is almost trivial:</p>\n<div class=\"gatsby-highlight\" data-language=\"(python)\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-(python) line-numbers\"><code class=\"language-(python)\">def render(text, breaks):\n    rendered = []\n    last = 0\n    for break in breaks:\n        rendered.append(text[last:break])\n        last = break\n    return rendered</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Obviously, adding styles and selections makes it more complicated, but the basic\nstructure is the same. However, if the document is very large, then recomputing\nthis on every keystroke is wasteful, much less serializing it and sending it over\nan RPC channel.</p>\n<p>Can we systematically transform this into an incremental algorithm? Why yes, we can.</p>\n<p>The first thing to notice is that every line is independent of every other line.\nIn addition, to actually draw pixels, we don't need all the lines, just the ones\nthat appear inside the viewport. When changes happen outside this viewport, ideally\nwe'd like to avoid sending an update at all (one way this can happen in practice is\nwhen making a <a href=\"rope_science_11.md\">syntax highlighting</a> change that ripples to the\nend of the document). Thus, we want to go beyond making it incremental and also make\nit <em>lazy</em> in a way, only spending the work to compute the slice or view that's\nactually needed. The front-end then holds not the entire result of the render\nfunction, but a cache of it, with each line either valid (and thus guaranteed to\nmatch the result of the render function), or invalid. When the front-end needs\na line not in the cache (for example, when scrolling), it requests it from the core.</p>\n<p>The version of the render function designed to compute a single rendered line at\na time is in a way even simpler:</p>\n<div class=\"gatsby-highlight\" data-language=\"(python)\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-(python) line-numbers\"><code class=\"language-(python)\">def render_line(text, breaks, line_num):\n    return text[breaks[line_num - 1] : breaks[line_num]]</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span></span></pre></div>\n<p>(Assume here that <code>breaks</code> is a fancy object that's designed to return 0 when\nindexed with -1.)</p>\n<h2 id=\"the-update-protocol\"><a href=\"#the-update-protocol\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The update protocol</h2>\n<p>Given that the output of our incremental render algorithm is a delta, we need a way\nto represent it explicitly. We then serialize the delta and send it from the core\nto the front-end as an asyncronous (but in-order) notification.</p>\n<p>The delta can be interpreted as a function from the previous value of the render\nfunction (a sequence of lines) to the next value. It's also worth being able to\nintrospect into this function, for example to know what's changed so only some\nlayers need to be re-rendered in a compositing UI pipeline.</p>\n<p>A slight complication is that lines in the front-end's cache might be invalid.\nIn our architecture, the core is in charge of which lines are valid (see #280 for\ndiscussion of this decision).</p>\n<p>The representation of deltas of this kind is reasonably well understood. The output\nof Unix <a href=\"https://en.wikipedia.org/wiki/Diff_utility\">diff</a>, for example, is a\nsequence of insert and delete operations interspersed with unmodified runs. The\ndetails of representation are not terribly important. In xi, we ended up with a\nsequence of <code>invalidate</code>, <code>skip</code>, <code>copy</code>, <code>ins</code>, and <code>update</code> operations (this last\nis for updating only styles and cursors when the text is otherwise unchanged). The\n<code>ins</code> operation is the same as diff, while deletion is represented as two <code>copy</code>\noperations with a <code>skip</code> in the middle. See <a href=\"frontend-protocol.md#xi-view-update-protocol\">Xi view update protocol</a> for detailed\ndocumentation on the update method.</p>\n<h2 id=\"the-render-plan\"><a href=\"#the-render-plan\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The render plan</h2>\n<p>In the current architecture, the core is in charge of the cache state,\nespecially which lines are valid and which lines are invalid. The core tracks\nthe scrolled viewport (through the <code>scroll</code> notification) but might lag behind.\nAll lines inside the viewport must be valid, in order to draw correctly. For\nlines outside the viewport, either choice is reasonable. Keeping a line valid\ncan be helpful on scrolling, as it then doesn't need to be requested from the\ncore, but it comes at a storage cost, so should be bounded (especially for large\ndocuments). In addition, when updating, actually visible lines <em>must</em> be the\npriority, as re-validating additional lines takes extra time to compute,\nserialize, and process.</p>\n<p>Thus, at every opportunity to update, xi produces a <em>render plan.</em> For every\nline, one of three things can happen: it can be discarded even if it was valid,\nit can be preserved if valid, or it can be rendered if invalid. The render plan\nchooses rendering for the visible viewport (plus a very small \"slop\" for\nscrolling), preserving for a range extending 1000 lines from the viewport, and\ndiscards the rest. The theory is that preserving existing valid lines comes at\na very small cost; no additional computation or communication is needed, just\nthe storage in the cache.</p>\n<p>Changing the viewport (for example, when scrolling) updates the render plan. In\naddition, the front-end can explicitly request additional lines, and those are\nadded to the render plan as well. For any given render plan, it's possible that\nan update would be a no-op, in which case it's not sent at all.</p>\n<p>The render plan is stored in the <code>RenderPlan</code> struct, in <code>line_cache_shadow.rs</code>.</p>\n<h2 id=\"computing-minimal-deltas\"><a href=\"#computing-minimal-deltas\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Computing minimal deltas</h2>\n<p>With these requirements, we can start looking at how to actually produce the\ndeltas. For any given editing operation, it would be possible to directly work\nout the corresponding delta to the render, but that is potentially a large\nnumber of cases, and also doesn't smoothly handle aggregating a sequence of\nchanges into a single render. There is a more systematic way.</p>\n<p>We propose a data structure here called the <em>line cache shadow.</em> It is\nessentially the skeleton of the render result, but stored in extremely\nlightweight form, and easy to update. Then, to actually produce the delta, we\ntraverse the render plan and the line cache shadow. Along with producing the\ndelta is a new line cache shadow, which, before any additional edits,\njust tracks which lines are valid.</p>\n<p>Conceptually, each line in the line cache shadow is either a reference to a\nline in the front-end's line cache, or an indication it is invalid. Updating\nthe shadow is straightforward: to insert a line, insert \"invalid\", and to delete\na line, delete it in the shadow. Note that in the delete case, a gap occurs in the\nreferences to the existing valid lines; when synthesizing the delta, this is\nthe cue to issue a <code>skip</code> command.</p>\n<p>Similarly, to rewrap a paragraph (changing line breaks in it), just replace\nthe range of lines of the paragraph with a new range, all invalid. And, using\nthe <a href=\"rope_science_06.md\">incremental re-wrap technique</a>, possibly the entire\nparagraph need not be invalidated.</p>\n<p>Synthesizing the delta from the shadow and render plan is then straightforward.\nWhen the plan calls for discarding, issue <code>skip</code>. When it calls for preserving,\nissue <code>invalid</code> for invalid lines in the shadow, or <code>copy</code> for valid lines.\nAnd when it calls for rendering, re-render and issue <code>ins</code> for invalid lines,\nand <code>copy</code> for valid lines. And for each <code>copy</code>, add a <code>skip</code> if the line number\nis not sequential.</p>\n<p>As a further refinement in practice, a line may be partially valid. A common\nand important case is that the text and styles are valid, but the cursor has\nchanged. We use a bitset to keep track of partial validity, and then when\nrendering partially valid lines send an <code>update</code> rather than an <code>ins</code>. For\ncursor movement, a sophisticated front-end might then just update the cursor\nlayer without needing to re-render any of the text.</p>\n<p>The line cache shadow data structure itself (<code>LineCacheShadow</code>) is extremely\nsmall and lightweight to compute, as it's stored in run-length form. In the\nabsolute worst case, upon edit the cache can just be replaced with a single\nspan indicating all lines are invalid.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>The mechanisms described here are fairly elaborate, but they all flow from a\nclear specification of the problem as a functional program, and from that we\ncan systematically derive the incremental algorithm. Further, the correctness\ncriterion is clear (applying the resulting delta should yield the same result\nas recomputing from scratch), and we hope to use property testing to ensure\nthat.</p>\n<p>Producing minimal deltas is key to xi delivering on its promised performance\ngoals, and should result in best-in-class latency and editing smoothness, all\nat minimal power costs.</p>","frontmatter":{"title":"Rope science, part 12 - minimal invalidation"}},"site":{"siteMetadata":{"title":"Xi-Editor","titleSeparator":"|"}},"allMarkdownRemark":{"edges":[{"node":{"id":"159ebaf9-aed2-5ad5-b403-f0a2c391cbef","fields":{"slug":"/frontend-notes/"},"frontmatter":{"title":"Notes on writing front-ends"}}},{"node":{"id":"db31e77f-3fda-57fc-9830-61c9f7c222dd","fields":{"slug":"/frontend-protocol/"},"frontmatter":{"title":"The Frontend Protocol"}}},{"node":{"id":"e81dd02d-d53d-5928-978d-37b7a16cdb61","fields":{"slug":"/plugin/"},"frontmatter":{"title":"Plugin architecture"}}},{"node":{"id":"056635a4-9cff-573b-9253-1c2afd68ff96","fields":{"slug":"/config/"},"frontmatter":{"title":"Working with the config system"}}},{"node":{"id":"ef83d327-af33-537c-b865-304c9cbd7567","fields":{"slug":"/crdt/"},"frontmatter":{"title":"CRDT - An approach to async plugins and undo"}}},{"node":{"id":"e7b10047-5613-53ea-bdeb-3989cfe8ac10","fields":{"slug":"/crdt-details/"},"frontmatter":{"title":"CRDT - The Xi Text Engine"}}},{"node":{"id":"8493f667-6117-50a0-bc92-21f304190a9f","fields":{"slug":"/fuchsia-ledger-crdts/"},"frontmatter":{"title":"CRDT - Using the Ledger for CRDTs"}}},{"node":{"id":"637adc80-f545-583f-b103-0e6256f0efe1","fields":{"slug":"/rope-science-00/"},"frontmatter":{"title":"Rope science - Introduction"}}},{"node":{"id":"d6abbbb0-ce0b-5810-8ab1-40db5f8fbb4d","fields":{"slug":"/rope-science-01/"},"frontmatter":{"title":"Rope science, part 1 - MapReduce for text"}}},{"node":{"id":"0b56a298-7fea-52be-b0c1-1924e8de94df","fields":{"slug":"/rope-science-02/"},"frontmatter":{"title":"Rope science, part 2 - metrics"}}},{"node":{"id":"f3d25a72-d849-52f7-8fb4-6d586db9b401","fields":{"slug":"/rope-science-03/"},"frontmatter":{"title":"Rope science, part 3 - Grapheme cluster boundaries"}}},{"node":{"id":"ed9dc1bf-9c35-58a0-b8ed-e702bdbc974f","fields":{"slug":"/rope-science-04/"},"frontmatter":{"title":"Rope science, part 4 - parenthesis matching"}}},{"node":{"id":"e3b3971e-a314-5c04-adc0-30c2e2f21345","fields":{"slug":"/rope-science-05/"},"frontmatter":{"title":"Rope science, part 5 - incremental word wrapping"}}},{"node":{"id":"271d1a9b-90e4-5315-b138-2a02a017e117","fields":{"slug":"/rope-science-06/"},"frontmatter":{"title":"Rope science, part 6 - parallel and asynchronous word wrapping"}}},{"node":{"id":"ef5e3b38-01da-5a9c-ad36-fce16dacff86","fields":{"slug":"/rope-science-08/"},"frontmatter":{"title":"Rope science, part 8 - CRDTs for concurrent editing"}}},{"node":{"id":"b73f0ca0-d039-531c-91a7-b8d0893fc5e8","fields":{"slug":"/rope-science-08a/"},"frontmatter":{"title":"Rope science, part 8a - CRDT follow-up"}}},{"node":{"id":"0c5f285f-2a9b-589f-8eff-a79435e54257","fields":{"slug":"/rope-science-09/"},"frontmatter":{"title":"Rope science, part 9 - CRDT Approach to Async Plugins and Undo"}}},{"node":{"id":"ef95af30-321f-5d87-a5e3-720e4eff00f9","fields":{"slug":"/rope-science-10/"},"frontmatter":{"title":"Rope science, part 10 - designing for a conflict-free world"}}},{"node":{"id":"4dd8698d-d45f-543c-9905-eba9659b68b0","fields":{"slug":"/rope-science-11/"},"frontmatter":{"title":"Rope science, part 11 - practical syntax highlighting"}}},{"node":{"id":"c8b885e6-57e4-5e66-9651-7b47f528793d","fields":{"slug":"/rope-science-12/"},"frontmatter":{"title":"Rope science, part 12 - minimal invalidation"}}}]}},"pageContext":{"id":"c8b885e6-57e4-5e66-9651-7b47f528793d"}}